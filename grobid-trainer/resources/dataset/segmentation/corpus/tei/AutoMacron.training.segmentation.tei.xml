<?xml version="1.0" ?>
<tei>
	<teiHeader>
		<fileDesc xml:id="0"/>
	</teiHeader>
	<text xml:lang="en">
			<front> Visual Compression of Workflow Visualizations <lb/>with Automated Detection of Macro Motifs <lb/> Eamonn Maguire, Student Member, IEEE, Philippe Rocca-Serra, Susanna-Assunta Sansone, Jim Davies, <lb/>and Min Chen, Member, IEEE <lb/> MOTIF EXTRACTION <lb/>ALGORITHM <lb/>RANKING <lb/>ALGORITHM <lb/>MACRO SELECTION <lb/>VIA UI <lb/>BIOLOGICAL <lb/>WORKFLOW <lb/>REPOSITORY <lb/>MACRO <lb/>SELECTION <lb/>GLYPH DESIGN <lb/>MACRO <lb/>ANNOTATION <lb/> 2.87 <lb/> OCCURRENCE <lb/> 1092 WORKFLOWS <lb/> 476 COMPRESSION <lb/> 3276 <lb/>2.4 <lb/> OCCURRENCE <lb/> 600 WORKFLOWS <lb/> 240 COMPRESSION <lb/> 2400 <lb/> SELECTED MACROS <lb/> DOMAIN EXPERT <lb/> Branch &amp; Merge <lb/> Branch &amp; Merge <lb/> F <lb/> A <lb/> s1 <lb/>s0 A <lb/>B <lb/>D <lb/>B <lb/>E <lb/>E <lb/>G <lb/>H <lb/> s2 <lb/>s3 <lb/> C <lb/>C <lb/> s4 <lb/> E <lb/>H <lb/>C <lb/>E <lb/> Branch &amp; Merge <lb/>Branch &amp; Merge <lb/> MACRO INSERTION <lb/>IN GRAPH <lb/>MOTIFS <lb/> ... <lb/> 2.87 <lb/> 1 <lb/> OCCURRENCE <lb/> 1092 <lb/> WORKFLOWS <lb/> 476 <lb/> COMPRESSION <lb/> 3276 <lb/>-2.43 <lb/> n <lb/> OCCURRENCE <lb/> 20 <lb/> WORKFLOWS <lb/> 10 <lb/> COMPRESSION <lb/> 200 <lb/> ... <lb/> DOMAIN EXPERT <lb/> Fig. 1. An overview of the processes implemented in our system, AutoMacron, for compression of workflow visualizations. A) <lb/>Biological workflows are imported from public repositories. B) The database of workflows is analyzed by our novel motif extraction <lb/>algorithm that is sensitive to node/edge types and is built using a state-transition approach. C) The algorithm generates a large list <lb/>of motifs. D) The motifs are ranked using metrics measuring their overall occurrence, scope of influence and compression potential. <lb/>E) Based on the ordered recommendations by the system as well as their own knowledge, domain experts explore the space of <lb/>motifs to identify suitable &apos;macros&apos;. F) A subset of motifs are selected for macro generation. G) A glyph is assigned to each macro <lb/>automatically using a design pattern that utilizes the state output from the motif extraction algorithm. H) Domain experts are able to <lb/>annotate macros with additional text labels. I) Macros can be inserted into the relevant workflows as a method for graph compression. <lb/> Abstract—This paper is concerned with the creation of &apos;macros&apos; in workflow visualization as a support tool to increase the efficiency <lb/>of data curation tasks. We propose computation of candidate macros based on their usage in large collections of workflows in data <lb/>repositories. We describe an efficient algorithm for extracting macro motifs from workflow graphs. We discovered that the state <lb/>transition information, used to identify macro candidates, characterizes the structural pattern of the macro and can be harnessed <lb/>as part of the visual design of the corresponding macro glyph. This facilitates partial automation and consistency in glyph design <lb/>applicable to a large set of macro glyphs. We tested this approach against a repository of biological data holding some 9,670 <lb/>workflows and found that the algorithmically generated candidate macros are in keeping with domain expert expectations. <lb/> Index Terms—Workflow visualization, motif detection, glyph-based visualization, glyph generation, state-transition-based algorithm <lb/></front>

			<body> 1 INTRODUCTION <lb/> The term &apos;macro&apos; is derived from the Greek word makro meaning big <lb/> or far. In computer science, the term is defined as &quot; a single instruction <lb/>that expands automatically into a set of instructions &quot; [4]. It is com-<lb/>monly used as a noun (e.g., a macro), or an adjective (a macro com-<lb/>mand). In schematic diagrams, such as electronic circuit diagrams, <lb/>data flow diagrams, and control engineering block diagrams, macros <lb/> are commonly used to provide hierarchical concept abstraction as well <lb/>as visual compression. Not only can macros facilitate &quot; overview first, <lb/>details on demand &quot; in visualization [35], but they can also speed up <lb/></body>

			<front> • Eamonn Maguire is with the Oxford e-Research Centre and Department of <lb/>Computer Science, University of Oxford, UK. E-mail: <lb/>eamonn.maguire@st-annes.ox.ac.uk. <lb/> • Philippe Rocca-Serra is with the Oxford e-Research Centre, University of <lb/>Oxford, UK. E-mail: philippe.rocca-serra@oerc.ox.ac.uk. <lb/> • Susanna-Assunta Sansone and Min Chen are with the Oxford e-Research <lb/>Centre, University of Oxford, UK. E-mail: <lb/>susanna-assunta.sansone@oerc.ox.ac.uk. <lb/> • Jim Davies is with Department of Computer Science, University of Oxford, <lb/>UK. E-mail: jim.davies@cs.ox.ac.uk. <lb/> • Min Chen is with the Oxford e-Research Centre, University of Oxford, UK. <lb/>E-mail: min.chen@oerc.ox.ac.uk. <lb/>Manuscript received 31 March 2013; accepted 1 August 2013; posted online <lb/>13 October 2013; mailed on 4 October 2013. <lb/>For information on obtaining reprints of this article, please send <lb/>e-mail to: tvcg@computer.org. <lb/></front>

			<body> visual search and reduce cognitive load for experienced users, who are <lb/>knowledgeable about or have become accustomed to the specification <lb/>of individual macros. In effect, their functionality bears some resem-<lb/>blance to acronyms. <lb/> This work is motivated by the need to reduce the visual complex-<lb/>ity of biological experiment workflows in an extension to work con-<lb/>ducted by Maguire et al. [24]. Such workflows describe the sequence <lb/>of processes (arranged with respect to a temporal dimension) enacted <lb/>on biological materials and signals obtained through experimental ob-<lb/>servations. Large repositories of experimental data offer a data corpus <lb/>that can be tapped into for workflow analysis and, more specifically, <lb/>detection of commonly-used subgraphs (also referred to as motifs). <lb/> Success in &quot; compressing &quot; such recurring motifs using macros would <lb/>significantly reduce the time required for creating, and perhaps more <lb/>importantly, viewing and comparing workflows. <lb/>When sketching out workflows on paper, individual scientists often <lb/>abstract a commonly performed sequence of steps into a macro proce-<lb/>dure or represent a set of parallel steps by using a macro step. Such a <lb/>macro encapsulates the sense of a bigger block, a higher-level abstrac-<lb/>tion, and multiple steps, just like in programming and other schematic <lb/>diagrams. Despite the potential benefits of using macros, one ma-<lb/>jor stumbling block that hinders the availability and use of macros in <lb/>workflow visualization is the lack of standards. Nevertheless, steps <lb/>towards standardization can be taken. With the availability of large <lb/>collections of workflows in biological experiment repositories, com-<lb/>putational approaches may be applied to detect commonly-used motifs <lb/>(i.e., topological patterns in workflows). It provides domain experts <lb/> with an objective means for establishing a list of candidate macros <lb/>based on their usage. The final selection of macros can be determined <lb/>semantically in traditional ways (e.g., community consensus, popular-<lb/>ity ranking or recommendations by standards bodies). <lb/>The main contributions of this work are as follows: <lb/> • Our overall approach for using a computational methodology to <lb/>identify candidate macros in relation to a workflow repository is <lb/>new. This enables exhaustive search and objective selection of <lb/>candidates while still allowing domain experts to make the final <lb/>decision on macro creation. <lb/> • We propose an efficient algorithm for extracting motif patterns <lb/>in workflows by taking into account node and edge types. This <lb/>enables motif grouping through inclusion of semantic context. <lb/>Our tests show that this type-sensitive algorithm performs faster <lb/>than existing generic algorithms in the literature; and <lb/> • Our motif extraction algorithm is based on a finite-state machine. <lb/>As workflows are directional and acyclic, the state transitions <lb/>for identifying a motif encode the structure of the motif. We <lb/>make use of such information to characterize the structural pat-<lb/>tern of selected macros visually. This facilitates partial automa-<lb/>tion when designing an individual glyph for each macro. <lb/> 2 RELATED WORK <lb/> Schematic representations of workflows are commonplace in a range <lb/>of disciplines. A workflow typically describes a sequence of steps, fol-<lb/>lowed from initiation to completion when conducting a piece of work. <lb/>Perhaps the most widely used workflow visualization is the Gantt <lb/> chart, which depicts tasks, resources and their dependencies in a tem-<lb/>poral manner. Efforts such as VisTrails [10], VTK [34] and SmartLink <lb/>[37] make use of workflows to depict the processes followed to create a <lb/>visualization. In Taverna [16] and Kepler [7], workflow visualization <lb/>allows users to build reproducible pipelines for data analysis. Other <lb/>workflow visualizations include the Business Process Model and No-<lb/>tation (BPMN), Petri-net, and programming flowchart, all of which <lb/>convey work flow, data flow and process interactions within often very <lb/>complex systems. <lb/>In this work, we consider workflows used to describe biological <lb/>experiments. This class of workflow visualization renders the pro-<lb/>cesses enacted on biological materials in experimental setups, from <lb/>sample collection through experimental perturbation to signal acquisi-<lb/>tion and interpretation. While most scientists have been using generic <lb/>text-based graph drawing tools such as GraphViz [1], new workflow <lb/>visualization tools are emerging (e.g., [24]). <lb/> Graph reduction is a family of algorithms and techniques for reduc-<lb/>ing visual complexity by using graph filtering and graph aggregation <lb/>[39]. Graph filtering involves removal of certain nodes and edges from <lb/>the graph, either deterministically or stochastically [22, 39]. Graph <lb/>aggregation selectively merges two or more nodes into one, hence pre-<lb/>serving some information about the nodes and edges to be removed. <lb/>Many selection algorithms exist, such as methods for building hier-<lb/>archical levels of detail, clustering based on node/edge attributes and <lb/>edge bundling for clutter reduction [39, 15]. <lb/>One subset of graph reduction techniques is motif based. Mo-<lb/>tifs, in the context of graphs, are &quot; patterns of interconnections occur-<lb/>ring in complex networks &quot; [25, 27]. A considerable amount of effort <lb/>has been dedicated to the automatic identification and characteriza-<lb/>tion of meaningful motifs in individual graphs or sets of graphs (e.g., <lb/>[18, 23, 41, 33, 38, 21, 12]). Replacing recurring motifs with macros <lb/>can provide hierarchical concept abstraction, visual compression, im-<lb/>proved readability and cost-effective task performance. Macros fea-<lb/>ture extensively in various graph representations, such as schematic <lb/>diagrams, communication network diagrams and workflow diagrams. <lb/>For example, VisMashup [31] utilizes macros to simplify the large <lb/>body of steps required to create a visualization. Dunne and Shnei-<lb/>derman propose to simplify graphs by using fan and arced glyphs to <lb/>represent common topological structures [12]. Shneiderman and Aris <lb/>propose the use of user-defined semantic substrates for compressing <lb/>network visualization [36]. However, determining suitable macros <lb/> Table 1. Some commonly used motif finding algorithms. <lb/> Algorithm <lb/> Sampling <lb/>Node Limit <lb/>Focus <lb/> mfinder [19] <lb/>exact &amp; estimated <lb/>6 <lb/>discovery <lb/>FPF (mavisto) [33] <lb/>exact <lb/>4 <lb/>search <lb/>FANMOD [41] <lb/>exact &amp; estimated <lb/>8 <lb/>discovery <lb/>NeMoFinder [11] <lb/>exact <lb/>12 <lb/>search <lb/>MODA [26] <lb/>exact <lb/>not defined <lb/>search <lb/>G-Tries [28] <lb/>exact <lb/> &gt; 9 <lb/>discovery <lb/>Grochow-Kellis [13] <lb/>exact <lb/>9 <lb/>search <lb/>Kavosh [17] <lb/>exact <lb/>8 <lb/>discovery <lb/>Color-coding [5] <lb/>estimated <lb/>10 <lb/>discovery <lb/> b) Generic motif discovery algorithm <lb/>c) Proposed type-sensitive algorithm <lb/> 2 times <lb/>2 times <lb/>2 times <lb/>12 times <lb/>1 time <lb/>1 time <lb/>1 time <lb/>1 time <lb/> a) an input graph <lb/> Vertex type <lb/>Edge type <lb/>Topology <lb/>Topology <lb/> 1 time <lb/>8 times <lb/> ... <lb/> Fig. 2. (a) A graph, with typed nodes and edges, where different node <lb/>types are mapped to different shapes and colours. (b) Generic motif dis-<lb/>covery (or search) algorithms focus on topological differences. (c) Our <lb/>motif extracting algorithm takes varying node/edge types into account, <lb/>yielding semantically aware motif grouping. <lb/> usually depends on both the semantic content of the corresponding <lb/>motif and its potential use in graph reduction. Hence, relying solely <lb/>on topological information may not lead to meaningful visualization, <lb/>while relying solely on user input does not scale up to a large collec-<lb/>tion of graphs. <lb/>As shown in Table 1, many motif search/discovery algorithms exist. <lb/>Ribeiro et al. [28], Kashani et al. [17] and Wong et al. [42] published <lb/>benchmarks detailing processing time for a subset of the algorithms <lb/>in Table 1. As subgraph matching is fundamentally an NP-complete <lb/> problem, these algorithms are computationally intensive. Wong et al. <lb/> report maVISTO taking 14,000 seconds to find size three motifs in an <lb/> E. Coli network. Comparing that to one second for FANMOD to an-<lb/>alyze the same network, one can see the huge variability in algorithm <lb/>performance. As the size of the target motifs grows, performance de-<lb/>creases. Using the same E. Coli network but searching for size 8 mo-<lb/>tifs, FANMOD will need 9000 seconds to finish the operation [42]. <lb/>In Table 1 the second column indicates whether the sampling in <lb/>a search space is exact (enumerating all possible candidates) or esti-<lb/>mated. The third column indicates the maximum number of nodes in <lb/>a motif the algorithm can handle. The final column indicates whether <lb/>the algorithm is focused on motif discovery (finding repetitive patterns <lb/>in a set of graphs), or motif search (finding a given motif in a set of <lb/>graphs). All these algorithms focus on topological patterns in graphs <lb/>only and do not consider the types of nodes and edges as a search con-<lb/>straint. As illustrated in Figure 2, these generic algorithms typically <lb/>focus on topological patterns in a graph. However, the types, or seman-<lb/>tic categories of nodes and edges are an interesting property in defining <lb/>a macro. There is a more semantically aware motif search algorithm <lb/>implemented in VisComplete [32, 20] that compares node labels and <lb/>node order to predict the next step in a VisTrails pipeline analysis over <lb/>a larger corpus of pipelines. However this algorithm is topologically <lb/>less sensitive and provides no way to identify branch/merge events <lb/>in a motif, or edge types. A potentially useful algorithm for identi-<lb/>fying suitable candidate macros should be type as well as topology <lb/> sensitive. Our work focuses on such an algorithm, offering additional <lb/>advantages in computational performance and providing visual map-<lb/>pings with meaningful structural information. <lb/>In our work, when considering whether a subset of steps in a given <lb/>workflow is the same as another subset in the same or a different work-<lb/>flow, we must consider the semantics attached to each step (see Figure <lb/>2). Consequently, the task of motif discovery and search is highly con-<lb/>strained by the types of nodes and edges. Therefore, it is necessary, as <lb/>well as advantageous, to develop specific motif extraction algorithms <lb/>for workflow visualizations. In addition, we propose a novel concept <lb/>of partially automating the design of macro glyphs. We consider the <lb/>use of multi-resolution glyphs to depict macros at different levels of <lb/>detail when a user interacts with the visualization, a technique referred <lb/>to as semantic zooming [9, 40]. <lb/> 3 MOTIVATION AND SYSTEM OVERVIEW <lb/> Over the past two decades, Biology has benefited from entering the <lb/>digital era, becoming a data intensive field. Ancillary to this devel-<lb/>opment, important efforts have been undertaken to preserve and cu-<lb/>rate digital artifacts in biology, including experimental workflows. A <lb/>workflow is a form of directed graph (digraph). Scientists mainly <lb/>rely on two types of workflow visualization: digraphs with text la-<lb/>beled boxes or glyph nodes. The latter enables more compact visual <lb/>representation than the former [24] allowing domain experts to per-<lb/>form their tasks such as error checking and comparison more quickly. <lb/>However, workflows can still be quite large and complex, contain-<lb/>ing many repeated subgraphs, which demand some effort for iden-<lb/>tification in &apos;flat&apos; representations. Hence, it is highly desirable to <lb/>introduce macro representations in workflow visualizations, as both <lb/>text-based and glyph-based workflow visualizations can benefit from <lb/>macro based visual compression. Although experimental workflows in <lb/>biology exhibit specific properties that are different from workflows in <lb/>other disciplines, they often share some characteristics. Almost all ex-<lb/>hibit temporal ordering and most feature only acyclic digraph topolo-<lb/>gies. We are therefore hopeful that our algorithm and experience can <lb/>be transferred to workflow visualizations in other disciplines. <lb/>The domain experts involved in this work (also co-authors of this <lb/>paper) identified the following requirements: <lb/>1. Given a number of workflows, can we obtain the most common <lb/>patterns/motifs within those workflows? <lb/>2. For each motif, can we obtain the occurrence frequencies for that <lb/>motif and information about which workflows they occur in? <lb/>3. Can we automatically create macro representations of those mo-<lb/>tifs, with the possibility of adding extra annotation to them? <lb/>4. Can motif patterns in a workflow be substituted by common <lb/>macros to make the workflow more compact? <lb/>Depending on discipline and requirements, macros may be created <lb/>by individuals based on their own knowledge about needs and usage. <lb/>However, such an individualized approach would be impractical if ap-<lb/>plied to the curation of large collections of experimental workflows as <lb/>found in data repositories. Yet, the availability of such data provides <lb/>an opportunity for the computational identification of commonly oc-<lb/>curring motifs in workflows. The statistics of such motifs offer useful <lb/>guidance to motif selection when defining macros. <lb/>To carry out this work, information was extracted from a curated re-<lb/>source currently holding over 22,000 experimental design workflows <lb/>(ArrayExpress) [2]. We used a subset of this collection, comprising <lb/>9,670 workflows considered to be well-formed with respect to cor-<lb/>rect connectivity and semantic annotation. This subset of workflows, <lb/>available in the ISA-Tab format [29, 30], offers a good representa-<lb/>tion of experiment typology. These ISA-Tab files were processed and <lb/>transferred to a graph database, which provides an optimized environ-<lb/>ment for storing graph structures and a query language optimized for <lb/>graph traversal [8]. For this purpose, we selected Neo4j [3] – a freely <lb/>available graph database providing a query language called Cypher, <lb/>fast traversal algorithms and high scalability (up to several billions of <lb/>nodes and edges on a single computer). <lb/> Fig. 3. In a workflow graph, some subgraphs can be considered as <lb/> &quot; legitimate motifs &quot; while others cannot, depending on node type. Invalid <lb/>motifs do not have the same output node type, as indicated by the differ-<lb/>ing colors. Conversely, valid motifs are those that have the same input <lb/>and output node type. <lb/> Our system consists of three main functional steps, as depicted in <lb/>Figure 1. (B, C, D) We algorithmically scan all workflows in the col-<lb/>lection and extract all valid subgraphs as candidate motifs. The pat-<lb/>terns and occurrence statistics of these motifs are recorded. The defini-<lb/>tion of validity and the extraction algorithm will be detailed in Sections <lb/>4.1 and 4.2. (E, F) We provide a user interface for domain experts to <lb/>define macros by selecting motifs from an ordered list of candidates, <lb/>based on the statistics computed as well as their domain knowledge <lb/>about individual motifs and the context of their usage. This will be <lb/>discussed in detail in Section 4.3. (G, H) We provide an automatic <lb/>means for defining the pictogram of a macro by making use of the <lb/>state transition information captured by the algorithm during the motif <lb/>discovery phase. In addition, each macro will normally be displayed <lb/>with a text label, which is defined by the domain expert through the <lb/>user interface. The mechanism for automatic creation of a pictogram <lb/>will be detailed in Section 5. <lb/>We created a tool, integrating the above requirements. The tool also <lb/>allows for substitution of frequent motifs with their macro counterparts <lb/>in experimental workflows. Furthermore, the tool can be deployed as <lb/>a standalone software package or exposed through an API. <lb/> 4 FROM MOTIFS TO MACROS <lb/> Motif discovery and substitution in graphs typically consists of four <lb/>processes [25, 6]: <lb/>1. Subgraph Generation: Scan each graph for all possible n-node <lb/> subgraphs. <lb/>2. Motif Amalgamation: Group together subgraphs that are topo-<lb/>logically equivalent and generate a representative subgraph of <lb/>each group (a motif). <lb/>3. Macro Selection: Assign a significance value to each motif with <lb/>respect to other motifs in the collection (for instance, by com-<lb/>puting frequency of occurrence) and select the most significant <lb/>motifs as macros. <lb/>4. Macro Substitution: Search graphs for subgraphs that match with <lb/>macros and replace them with that macro. <lb/>In applications such as biological network rendering, it can be <lb/>safely assumed that subgraphs should be connected. By contrast, in <lb/>applications such as very-large-scale integration (VLSI) design, such <lb/>a condition is sometimes relaxed, as macros are often used to group <lb/>elements for a cost-effective spatial placement. In general, the number <lb/>of subgraphs can be rather large. That is why many algorithms only <lb/>deal with small subgraphs, such as the 4-node subgraphs studied in <lb/>[25]. <lb/> 4.1 Candidate Macros in Workflows <lb/> The workflows and macros considered in this work exhibit the follow-<lb/>ing characteristics: <lb/> s <lb/> s 1 <lb/> s 0 <lb/> A <lb/>A <lb/> s 1 <lb/> s 0 <lb/> s 0 <lb/> s 3 <lb/> s 3 <lb/> s 0 <lb/> C <lb/>B <lb/> s 1 <lb/> D <lb/> s 3 <lb/> s 2 <lb/> m <lb/>m <lb/>m k <lb/>2 <lb/>1 <lb/> E s 4 <lb/> s 1 <lb/> s 0 <lb/> s 4 <lb/> G <lb/> m <lb/> (a) singular branching <lb/>(b) homogeneous branching <lb/>(c) heterogeneous branching <lb/> Fig. 5. Examples of state transitions with different rules. Homogeneous edges are depicted by using the same color. <lb/> A <lb/> a normal state, with <lb/> s 1 <lb/> s 0 <lb/> A <lb/>B <lb/>D <lb/>B <lb/>E <lb/>E <lb/>G <lb/>H <lb/> a holding state, with <lb/>a pseudo-moƟf <lb/>a &apos;&apos;legal&apos;&apos; moƟf <lb/> s 2 <lb/> s 3 <lb/> C <lb/>C <lb/> s 4 <lb/> F <lb/>E <lb/>H <lb/> a starƟng state <lb/>a transiƟon that <lb/>generates a moƟf <lb/> C <lb/>E <lb/> generates a moƟf <lb/>a transiƟon does not <lb/>generate a moƟf <lb/> Fig. 4. The state transitions in motif generation. <lb/> 1. A workflow is an acyclic digraph. <lb/>2. A macro must consist of at least two nodes/nodes. <lb/>3. Macros are not only topologically sensitive, but also semanti-<lb/>cally sensitive. In other words, two subgraphs are said to be in <lb/>the same motif group only if they are isomorphic and every pair <lb/>of corresponding nodes (and edges) are of the same type. <lb/>4. It is not necessary to have a path between every pair of nodes in <lb/>a motif. <lb/>5. For each node in a macro, there must exist a path from the <lb/>macro&apos;s input node, and a path to the macro&apos;s output node. <lb/>6. Each macro must have a single input type and a single output <lb/>type (including bundled input and output). <lb/>7. A bundled input or output may contain any number of connection <lb/>edges, but they must be of the same material type. <lb/>8. A macro may receive a bundled input converging from different <lb/>preceding nodes and may deliver a bundled output branching off <lb/>to different successive nodes. <lb/>By relying on these characteristics we can significantly reduce the <lb/>number of subgraphs and motifs to be extracted in the motif generation <lb/> stage of the algorithm. Figure 3 illustrates those subgraphs that are <lb/>&apos;legitimate&apos; candidates and others that are &apos;illegitimate&apos;. In addition, <lb/>owing to characteristic three described above, the Motif Amalgamation <lb/> and Macro Substitution stages are much less onerous in comparison to <lb/>subgraph matching based on topology only. <lb/> 4.2 Motif Generation <lb/> Owing to the aforementioned conditions that are specific to workflows, <lb/>we could not make use of existing motif generation software and algo-<lb/>rithms such as those surveyed in [42]. A specialized motif generation <lb/>algorithm was needed, and for that we adapted the widely accepted <lb/>&apos;pattern-growth&apos; approach [42]. We describe the algorithm by evolv-<lb/>ing a state transition diagram as shown in Figure 4. <lb/> Singular Branching (Rule A). As shown in Figure 5(a), the simplest <lb/>workflow is perhaps a single path composed of n different steps (e.g. <lb/>experimental steps). The algorithm can be activated from any node and <lb/>will only move forward, following the flow of the work. Since a single <lb/>node cannot be a macro, the search will park at state S  0 as illustrated <lb/>in Figure 5(a), where the orange background indicates a starting state <lb/>and the dotted outline implies that it is only a holding state and does <lb/>not output a &quot; legitimate motif &quot; . <lb/>When the algorithm encounters the next node n  1 , it obtains the first <lb/>&apos;legitimate motif&apos;, m  1  = n  0  → n  1  , and moves to the state S  0 . The <lb/>edge is labeled with A indicating that this follows rule A. From n  1 , <lb/>the algorithm then encounters n  2 , it outputs another motif m  2  = n  0  → <lb/> n  1  → n  2  , and remains at the same state. For the workflow in Figure <lb/>5(a), this self-loop continues to generate motifs in growing sizes until <lb/>the end of the path or the number of nodes in the motif reaches a <lb/>predefined maximum. <lb/> Homogeneous Branching (Rules B, C, D). One extension of the sin-<lb/>gular branching case is multiple runs of the same sequence of steps, in <lb/>parallel. When the work flows forward, the same type of edges connect <lb/>to the next set of nodes. These edges can consist of bundled together <lb/>as an input or output of a macro motif (see condition 7 in Section 4.1). <lb/>When an edge first branches to multiple nodes, as illustrated in Fig-<lb/>ure 4, the algorithm moves from state S  0 or S  1 to S  3 , following a <lb/>transition of singular branching to bundled homogeneous branching. <lb/>This is referred to as rule B. S  3 indicates more than one edge is being <lb/>bundled at this state and the number of edges may vary. <lb/>The algorithm will self-loop as long as the motif grows with such <lb/>bundled edges. Rule C indicates a transition within the state of ho-<lb/>mogeneous branching. The number of edges in an edge bundle can <lb/>change as long as there is more than one edge and they are of the same <lb/>type. <lb/>When all bundled branches converge to a single node, the algorithm <lb/>returns to state S  1 . This transition is referred to as rule D. Figure <lb/>5(b) shows three examples of applying rules B, C and D respectively. <lb/>Applying any of the three rules will result in a bigger motif than the <lb/>previous one. <lb/>An additional state S  2 is included for a scenario when the algorithm <lb/>starts with a row of parallel nodes with bundled input and output. We <lb/>will discuss this scenario later in the context of reactivating the algo-<lb/>rithm for bundled edges. <lb/> Heterogeneous Branching (Rules E, F, G, H). Recall conditions 6 <lb/>and 7 in Section 4.1: a macro must have a single input and single <lb/>output and each can be bundled edges of the same material type. When <lb/>these two conditions are met, we can have heterogeneous flow within <lb/>a macro. This subset of rules is designed to &apos;grow&apos; this particular type <lb/>of motif. <lb/>Rule E is applied when the algorithm first encounters an heteroge-<lb/>neous pattern. This transition leads to a holding state S  4 and it does not <lb/>generate any motif. In this state, all nodes scanned so far are grouped <lb/>as an interim pseudo-motif and output edges are placed in an interim <lb/>pseudo-bundle. <lb/>The interim state is maintained by a self-loop transition; i.e., rule F <lb/> as long as the bundled edges remain heterogeneous. When the edges <lb/>in an interim pseudo-bundle finally converge to a single node or a set <lb/>of nodes with homogeneous output edges, the algorithm can leave the <lb/>holding state S  4 . Rule G defines the transition to singular branching <lb/>state S  1 , while rule H defines the homogeneous branching state S  3 . <lb/>Both rules will generate a new motif, which includes all nodes in the <lb/>interim pseudo-motif and the newly encountered node(s). <lb/> Termination and Reactivation. The algorithm strictly follows the <lb/> Table 2. Performance of our motif-finding algorithm on graphs of varying <lb/>size and at a range of search depths. Averages (last column) are taken <lb/>across three graphs G1, G2 and G3 in each category. For each graph <lb/>at each depth, the recorded time was the average time over five runs. A <lb/>more detailed table is available in the supplementary materials. <lb/> Graph Size Motif Depth G1 <lb/>G2 <lb/>G3 <lb/>Seconds <lb/> 3 0.018 0.017 0.024 <lb/>0.02 <lb/>4 0.034 0.026 0.025 <lb/>0.03 <lb/>5 0.048 0.038 0.042 <lb/>0.04 <lb/>6 0.059 0.041 0.046 <lb/>0.05 <lb/>Small <lb/>7 0.075 0.049 0.049 <lb/>0.06 <lb/>8 0.086 0.063 <lb/>0.06 <lb/>0.07 <lb/>9 0.095 0.064 0.062 <lb/>0.07 <lb/>10 0.106 0.069 0.072 <lb/>0.08 <lb/>3 0.153 0.065 0.056 <lb/>0.09 <lb/>4 0.212 0.097 0.085 <lb/>0.13 <lb/>5 <lb/>0.24 <lb/>0.13 0.115 <lb/>0.16 <lb/>6 0.293 0.161 0.138 <lb/>0.2 <lb/>Medium <lb/>7 0.343 0.189 0.159 <lb/>0.23 <lb/>8 0.389 0.219 0.178 <lb/>0.26 <lb/>9 0.429 0.241 0.183 <lb/>0.28 <lb/>10 0.477 0.287 0.192 <lb/>0.32 <lb/>3 0.296 0.756 0.354 <lb/>0.47 <lb/>4 0.393 1.062 <lb/>0.45 <lb/>0.64 <lb/>5 0.652 1.309 0.414 <lb/>0.79 <lb/>6 0.632 1.528 <lb/>0.42 <lb/>0.86 <lb/>Large <lb/>7 <lb/>0.75 1.829 0.341 <lb/>0.97 <lb/>8 0.809 2.028 0.396 <lb/>1.08 <lb/>9 0.889 2.287 0.528 <lb/>1.23 <lb/>10 1.047 2.489 0.604 <lb/>1.38 <lb/> Fig. 6. Scatter plot showing the distribution of workflows (each depicted <lb/>as a point) as node count versus edge count. <lb/> breadth-first search strategy. It may terminate in two situations: (a) <lb/>when the predefined maximum depth that a macro may be at is <lb/>reached; (b) when it encounters a node without an output edge (i.e., <lb/>the termination point of a workflow). The termination condition is <lb/>tested in all states in Figure 4. <lb/>It is necessary to reactivate the algorithm by choosing each of the <lb/>different nodes in a workflow as a starting node at state S  0 . In ad-<lb/>dition, each bundle of edges of the same material type can also be a <lb/>starting point at S  2 . Although theoretically appropriate, invoking the <lb/>algorithm recursively from a starting node of a workflow proved not to <lb/>be feasible in practice. We therefore made use of a queue, which ini-<lb/>tially contains all nodes in a workflow. We fetch nodes from the queue <lb/>one at time to invoke the algorithm from S  0 . Every time the algorithm <lb/>reaches state S  3 , we have a set of homogeneous nodes that were just <lb/>encountered (e.g., [n  1a  , n  1b  , n  1c  ] in Figure 5(b)). We store all k-node <lb/> subsets of such a set (k = 2, 3, . . .) in a list. When we finish with all <lb/>individual nodes in the queue, we sort the list and remove redundant <lb/>subsets. We then invoke the algorithm with the sorted and cleaned list <lb/>from S  2 . Note that each subset in the list is a &apos;legitimate motif, hence <lb/> S  2 is not a holding state. <lb/> Performance. To evaluate the performance of the algorithm, we tested <lb/>it against nine graphs representing biological workflows of varying <lb/>sizes on a MacBook Pro with a 2.53GHz Intel Core i5 CPU and 8GB <lb/>RAM. The nine graphs were divided into three groups, three small, <lb/>three medium and three large, based on their node and edge counts. <lb/>Figure 6 shows the distribution of workflows in our collection in terms <lb/>of nodes (x-axis) and edges (y-axis). 93% of all workflows have a <lb/>node count below 1000 and the average number of nodes per workflow <lb/>is approximately 322. Given these statistics, we define small as 200 <lb/>nodes or below (covering 58% of workflows); medium between 201 <lb/>and 600 nodes (covering a further 28% of workflows); and large over <lb/>601 nodes (covering the remaining 14%). <lb/>For each of the nine selected graphs, motifs between a depth of <lb/>three and ten were searched for, with each search repeated 5 times <lb/>to account for any variability. Table 2 gives the runtime (in seconds) <lb/>of applying our algorithm to the nine test graphs. The runtime is scal-<lb/>able to our collection of some 10,000 workflows, as the algorithm runs <lb/>as a batch process. It also shows that the speed of our motif finding <lb/>algorithm compares favorably the current best general purpose motif <lb/>finding algorithms. <lb/>Our algorithm search space differs from the general purpose algo-<lb/>rithms listed in Table 1, since we have introduced specific constraints <lb/>on motif structure, taking into account the notion of node/edge types. <lb/>Nevertheless, we could have theoretically used a two-stage method, by <lb/>first using a general-purpose algorithm to identity an initial list of mo-<lb/>tifs, then filtering out those motifs that do not meet our requirements. <lb/>Since our algorithm is generally faster than these general purpose al-<lb/>gorithms, plus the computation to infer back the node/edge type is po-<lb/>tentially large, there is no advantage to using this two-stage approach. <lb/> 4.3 Selecting Macros from Candidate Macros <lb/> Given a list of motifs extracted using the algorithm in Section 4.2, we <lb/>can categorize them into individual groups. Motifs in each group share <lb/>the same subgraph topology, and the same set of nodes and edges in <lb/>terms of their numbers and types. Each motif group thus becomes a <lb/>candidate macro. It is important to emphasize that selecting macros <lb/>from macro candidates requires a fair amount of knowledge about bi-<lb/>ology, biological experiments and the uses of workflows. In some <lb/>cases, other information, such as the time when and context in which <lb/>certain motifs appear frequently, may also feature in the selection pro-<lb/>cess. Therefore, it is not sensible to make this selection process fully <lb/>automatic. In this work, we provide a user interface to assist domain <lb/>experts in selecting macros from a large list of candidates. <lb/>Following the advice of domain experts specialized in biological <lb/>data curation, we understood the essential requirement for such a user <lb/>interface is to provide key indicators for each macro candidate g i  , in-<lb/>cluding the depth of its subgraph, A d  (g  i  ), the total number of its oc-<lb/>currences in the data repository, A t  (g  i  ), the number of workflows that <lb/>contain it, A w  (g  i  ), and its compression power A c  (g  i  ). For each indi-<lb/>cator, normally the higher value the indicator has, the more selectable <lb/>the candidate is. However, when the comparison is not clear cut across <lb/>different indicators, the domain experts will have to make an informed <lb/>decision based on all the indicators as well as their tacit knowledge <lb/>about the macro candidate (e.g., biological semantics, importance in <lb/>science, expected future usage). As shown in Figure 7B, the user inter-<lb/>face displays each candidate with these indicators. The candidates are <lb/>organized into columns, each representing a specific depth of the sub-<lb/>graphs in all macro candidates. Each candidate is shown with the basic <lb/>pattern along with three indicators, A t  , A w  , A c  . The detailed structure <lb/>of each macro candidate can be viewed on demand by using mouse <lb/>interaction. <lb/>In order to help domain experts examine a large number of candi-<lb/>dates speedily, we sort macros candidates in each column by a ranking <lb/>score, allowing domain experts to inspect the most promising candi-<lb/>date first. The ranking score is based on indicator A t  , A w  , and A c  . <lb/> Indicator 1: Occurrences in the data repository. Indicator A t  re-<lb/>turns the total number of times a motif has occurred across the entire <lb/>database of workflows. It emphasizes the importance in selecting mo-<lb/>tifs that are highly used, inferring their functional importance. <lb/> Indicator 2: Workflow presence. Indicator A w  returns the total num-<lb/>ber of workflows in which a motif has appeared. This provides a mea-<lb/>sure of how widely a motif is used across different biological exper-<lb/>iments, counterbalancing the possible distortion in situations where a <lb/>motif is heavily used in a relatively small number of workflows. <lb/> Indicator 3: Compression Potential. Indicator A c  is calculated by <lb/>first subtracting the number of nodes in the motif (A  n  ) by 1, since these <lb/> Occurrences es Workflow <lb/>presence <lb/>Score <lb/>Compression <lb/>Potential <lb/> A <lb/> B <lb/>C <lb/> p <lb/>3 Normalized metrics <lb/>Motif subgraph 3 Glyph representations <lb/>Filter by pattern presence <lb/>Linear, branching and merging <lb/> D <lb/> Filter by <lb/>min/max depth <lb/>Downgrade <lb/>Icon <lb/>Adjusted <lb/>Score <lb/>L L <lb/>Motifs arranged <lb/>by depth <lb/>Depth 6 motifs with <lb/>magnified view in B <lb/>and detailed popup of <lb/>selected motif in D <lb/> Fig. 7. AutoMacron provides a user interface (A) for domain experts to select macros from a list of computed motifs. As shown in the detailed view <lb/>in (B), the overall score determines the order of motifs in the list. The three indicators are shown in unnormalized form in order to be semantically <lb/>meaningful. The detail view (C) shows an example where a score is adjusted dynamically when a motif encompassing other motifs is selected. (D) <lb/>shows a pop-up window for a specific macro, detailing its subgraph and three automatically generated pictograms for different levels of details in <lb/>visualization. <lb/> nodes will be replaced by a single macro node, and then multiplying <lb/>by its occurrence (A  t  ). It is written as A c  (g  i  ) = (A  n  (g  i  ) − 1)  *  A t  (g  i  ). <lb/> For each of these three indicators, we map it to a fixed range [−1, 1] <lb/>using a linear mapping based on the min-max range of each indicator, <lb/>yielding three normalized metrics M  1 , M  2 and M  3 . These are com-<lb/>bined into a single ranking score using a weighted average as: <lb/> S(g i  ) = <lb/> 3 <lb/> ∑ <lb/> k=1 <lb/> ω  k M k  (g  i  ) <lb/> where  ω  k  are three weights defined by users. Our system makes no <lb/>assumptions about the merits of one indicator over another, so the de-<lb/>fault weights are set to one. We chose to have the score S(g i  ) in the <lb/>range of [−3, 3], as it helps domain experts to connect the score back <lb/>to the three indicators. <lb/>Figure 7 shows a screenshot of the user interface on the left (A), and <lb/>two detailed views with annotation on the right (B, C). A domain ex-<lb/>pert normally examines macro candidates with the largest depth value <lb/>(the rightmost column) first. Once a motif, M , is selected, it may af-<lb/>fect the current results returned by the indicators. As such a motif, M , <lb/>may contain many other candidate motifs as subgraphs. It is important <lb/>for the domain expert to be aware of the impact of this decision on <lb/>those candidate motifs yet to be examined. The system thus updates <lb/>the indicators of all those candidate motifs included in M . Instead <lb/>of modifying A t  and A w  directly, the system shows a corrected score <lb/>calculated by considering the new values for A t  , A w  and A c  , implying <lb/>the difference if all M were to be removed from the repository. <lb/> 5 MACRO DESIGN <lb/> Having obtained a collection of motifs suitable for use as macros <lb/>within our corpus of workflows, we now have the task of designing <lb/>their visual representation. It is important to keep the users in mind <lb/>and ensure that the design reflects what a typical user, in our case a bi-<lb/>ologist, would expect to find in a macro. We consulted domain experts <lb/>as to the visual elements that users considered the most important to <lb/>view. A number of attributes were identified and are listed below in <lb/>order of importance: <lb/>1. an impression of topology/structure within a macro (e.g., it may <lb/>be an entirely linear path, a set of parallel paths, or it may contain <lb/>branch/merge events); <lb/>2. an impression of types of nodes in a macro (e.g., the overarching <lb/>theme of the macro); <lb/>3. textual description, (i.e., additional annotation to provide con-<lb/>crete semantic meaning and help in understanding); <lb/>4. an impression of density within a macro, (i.e., the size of the <lb/>corresponding subgraph). <lb/>Given the attributes listed above, we devised three design options, <lb/>as illustrated in Figure 8, for creating pictograms. These pictograms <lb/>are created automatically based on the states encountered when the <lb/>motif is found by the motif generation algorithm in Section 4.2. When <lb/>the algorithm moves from one state to another, the pictogram grows <lb/>by adding a new visual component reflecting the subgraph pattern just <lb/>encountered. We provide three alternative designs for each macro. <lb/>The first option is pixel-based, the second is shape-based and the third <lb/>is a miniature version of the subgraph. All three design options are <lb/>stored as vector graphics, so they are suitable for multi-scale display, <lb/>for example, through zooming operations. Textual descriptions of the <lb/>macros are always provided by experts. <lb/>Figure 7(D) shows a pop-up window with a detailed view of a <lb/>macro, and the three design options. The users can choose to have <lb/>a fixed design for the macro, or have a multi-scale variation according <lb/>to the level of detail at which a user is viewing the workflow. <lb/> Overview/Low detail. At the overview level, the fine-grained details <lb/>of the workflow (e.g., lines) utilize visual channels occupying a high <lb/>spatial frequency. It is more effective for nodes in a graph to occupy <lb/>low spatial frequencies, which will be distinguishable by a user. The <lb/>pixel-based design option enables users to use visual channels that are <lb/>visible and roughly distinguishable in low spatial frequencies. Al-<lb/>though individual nodes and edges are not visible, the user can still <lb/>gain a rough impression about the topology and node types. <lb/> Medium detail. At medium detail, users should be able to see more <lb/>information through the shape-based design. The major steps from <lb/>input to output (i.e., following the state transitions) become more dis-<lb/>tinguishable. Each horizontal segment of the pictogram is colored by <lb/> annotation <lb/> annotation <lb/> STATE-TRANSITION MODEL <lb/>EXAMPLES <lb/> Node type <lb/> colour/shape <lb/> Node type <lb/> colour/shape <lb/> Length <lb/>Topology <lb/> arrangement <lb/> Breadth <lb/>Topology <lb/> arrangement <lb/> Breadth <lb/>Topology <lb/> overall <lb/> Node type <lb/> colour <lb/> Length <lb/>Breadth <lb/>Length <lb/> A <lb/> s 1 <lb/> s 0 <lb/> A <lb/>B <lb/>D <lb/>B <lb/>E <lb/>E <lb/>G <lb/>H <lb/> s 2 <lb/> s 3 <lb/> C <lb/>C <lb/> s 4 <lb/> F <lb/>E <lb/>H <lb/>C <lb/>E <lb/> s 1 <lb/> s 0 <lb/> A <lb/> A <lb/> s 1 <lb/> s <lb/>s 0 <lb/> s 3 <lb/> B <lb/> s 1 <lb/> s 3 <lb/> C <lb/> A <lb/> s 1 <lb/> E s 4 <lb/> s 1 <lb/> s 4 <lb/> F <lb/> s 1 <lb/> s 4 <lb/> G <lb/> annotation <lb/> Fig. 8. From left to right: automatic generation of a micro pictogram based on the state transitions encountered. The lower three rows: Three <lb/>design options for representing macros. <lb/> node type, branching and merging is shown with triangles of mir-<lb/>rored directionality, and heterogeneity of nodes is depicted in sepa-<lb/>rated tracks of differing colors. <lb/> High detail. When a user zooms into a small region of the visualiza-<lb/>tion, a miniature version of the subgraph becomes available, showing <lb/>details of the topology and node types. This representation has a lot <lb/>of high spatial frequency information and is only suitable for detailed <lb/>examination in close up views. <lb/> 6 SOFTWARE IMPLEMENTATION AND USE <lb/> To demonstrate our approach, we developed an open-source Java tool <lb/>named AutoMacron that may be used in two modes: 1) standalone <lb/>for those wishing to discover common motifs in a database of graphs; <lb/>and 2) as an API for those wishing to integrate the utilities for motif <lb/>discovery into their own software. We are also in the process of adding <lb/>the capability to import formats other than ISA-Tab. The software <lb/>provides the following functionalities: <lb/>1. Load files that have a handler (e.g., ISA-Tab in our use case) into <lb/>a graph database; <lb/>2. Analysis of all graphs in the database instance to determine the <lb/>dominant motifs; <lb/>3. Allow for selection of macros from the pool of over-represented <lb/>motifs found by the algorithm; <lb/>4. Visualize graphs both in uncompressed/compressed representa-<lb/>tions, and/or export those graphs in GraphML format for visual-<lb/>ization in other environments; <lb/>5. Render differing images depending on the zoom level (semantic <lb/>zooming [9, 40]). For this, we have extended the Prefuse visual-<lb/>ization library [14]. <lb/>6. Allow for search of a graph database for a user-defined <lb/>semantically-annotated motif; <lb/>7. Export macros for use in other software. <lb/>Using AutoMacron, over 12,000 valid motifs were found in a col-<lb/>lection of 9,670 existing workflows from ArrayExpress. From that set, <lb/>those motifs scoring below zero with the aforementioned aggregated <lb/>score S(g i  ) were removed from consideration leaving just over 400 <lb/>candidates. <lb/>Further examination of these candidates was conducted by domain <lb/>experts using the macro selection utility shown in Figure 7. Examina-<lb/>tion is aided through both presentation of the metrics and &apos;live&apos; high-<lb/>lighting of motif representations as they occur in the original graph <lb/>representation. Following the manual selection of 30 of these macros, <lb/>the domain experts labeled each macro with a textual description, mak-<lb/>ing the corresponding glyphs more meaningful and identifiable. These <lb/>macros could then be used to substitute the more complex representa-<lb/>tions in the original graph in an effort to compress the representation. <lb/>Aside from the dedicated AutoMacron tool, the motif finding func-<lb/>tionalities have been incorporated into ISAcreator, which is a tool <lb/>used by domain scientists to annotate and curate biological experiment <lb/>workflows and other necessary documentation. As shown in Figure 9, <lb/>the user is given the option to compress an experiment workflow using <lb/>the macros selected by domain experts for biological data curation. <lb/> 7 EVALUATION <lb/> Aided by direct collaboration and regular interaction with domain ex-<lb/>perts, development of the software followed an evolutionary proto-<lb/>typing process whereby users evaluated the prototype at every major <lb/>stage of the development. For each prototype users contributed their <lb/>feedback to the software and algorithm outputs. <lb/>In this section, we summarize the feedback given from the last itera-<lb/>tion where we performed the following: 1) analysis of the performance <lb/> A <lb/> B <lb/> Fig. 9. A) A typical workflow, where a 4-node motif was selected as a macro using AutoMacron, which provides ISAcreator with an API. (B) A <lb/>screenshot of ISAcreator, where each occurrence of the original 4-node motif has been replaced with a macro glyph. <lb/> of the algorithm presented in this paper in comparison with that of the <lb/>best existing (and available) algorithm; and 2) observation of how the <lb/>software met the initial requirements as identified in Section 3 by in-<lb/>terviewing expert users. <lb/> 7.1 Evaluation Against Existing Algorithms <lb/> We wished to test the performance of the best in class in existing algo-<lb/>rithms with that of the algorithm presented in this paper, not necessar-<lb/>ily just in speed, but also in what was found and how that compared <lb/>with domain experts&apos; expectations. We compared the performance of <lb/>FANMOD [41] and the algorithm presented in this paper in an attempt <lb/>to discover which motifs could be found and how they related to the <lb/>expectations of domain experts. <lb/>Firstly, we ran a simple test graph through FANMOD, to detect <lb/>three, four, five, six, seven and eight node graphs. In FANMOD, there <lb/>is a requirement to run each analysis separately, searching for size 8 <lb/>node subgraphs does not yield all three to eight node subgraphs. Fig-<lb/>ure 10B shows the output of a four node motif analysis and highlights <lb/>FANMODs motif discovery match for a pattern highlighted in Fig-<lb/>ure 10A. As aforementioned, there is no notion of node or edge type, <lb/>therefore all four node graphs with the same serial topology will be the <lb/>same, even though they represent entirely different concepts. Addi-<lb/>tionally, FANMOD, typical of the existing class of algorithms, returns <lb/>invalid results with respect to our definition of a motif as defined in <lb/>Section 4.1. <lb/>Following this, we ran the same graph through AutoMacron to gen-<lb/>erate motifs up to depth 8. Note that FANMODs restriction is on node <lb/>number (up to eight), whereas our algorithm can have potentially hun-<lb/>dreds of nodes at depth eight. Figure 10C shows the HTML output <lb/>from AutoMacron&apos;s analysis. The highlighted motif corresponds to <lb/>those highlighted in Figures. 10A and B, we magnify the motif to show <lb/>how our algorithm identifies the exact pattern with topology, node and <lb/>edge type preserved. <lb/>Finally, we had the domain expert who inspected the graph manu-<lb/>ally and extract the motifs they would expect the algorithm to find. We <lb/>compared what FANMOD and AutoMacron found with what the user <lb/>expected. Our summary results are shown in table 3 with all analy-<lb/>sis outputs available at https://bitbucket.org/eamonnmag/automacron-<lb/>evaluation. <lb/>The results show that AutoMacron identifies less macros that FAN-<lb/>MOD, however if one was to consider all the invalid motifs Au-<lb/>toMacron filters out due to incompatibility with our rule set (see Sec-<lb/>tion 4.1), AutoMacron would have reported many more. When we <lb/>consider just the &apos;valid&apos; motifs, AutoMacron has many more than <lb/>FANMOD (fifty compared with nineteen for FANMOD). This is as <lb/>a direct result of the semantics added by AutoMacron. To illustrate, <lb/> Table 3. Results of motif identification by the domain expert, FANMOD <lb/>and AutoMacron. Analysis included: MIdent -the ability of the do-<lb/>main expert to identify motif pictograms generated by the algorithms <lb/>and match them to the original graph; and UIdent -the percentage of <lb/>motifs found by the algorithm with respect to the number identified man-<lb/>ually by the domain expert. <lb/> Source <lb/> Motif Id. Valid Motifs <lb/>Acc <lb/>MIdent <lb/>UIdent <lb/>Time (ms) <lb/> Domain Expert <lb/>6 <lb/>6 <lb/>n/a <lb/>n/a <lb/>n/a <lb/>n/a <lb/>FANMOD <lb/>73 <lb/>19 <lb/>26% <lb/>4/19 (21%) <lb/>5/6 (83%) <lb/>1030* <lb/>AutoMacron <lb/>50 <lb/>50 <lb/>100% 49/50 (98%) 6/6 100% <lb/>119 <lb/> consider a simple two node directed subgraph (v → v) with 3 possible <lb/>node types (n), AutoMacron could theoretically identify n(n − 1) dif-<lb/>ferent motifs whereas FANMOD and other algorithms already listed <lb/>here could only identify one. Figure 10B and C show for instance how <lb/>one 4-node motif found in FANMOD maps to five potential, but only <lb/>one correct motif in AutoMacron. Overall both algorithms identified <lb/>the majority of motifs expected by the user, not unexpected consid-<lb/>ering both mechanisms are exhaustive, however FANMOD struggled <lb/>when it came to identifying the larger motifs, due to the node limit of <lb/>eight, hence its UIdent value of 83%. <lb/>The user was also asked to identify motifs based solely on the pic-<lb/>tograms representing topology (macros) output from each program. In <lb/>98% of occasions, the user could identify AutoMacron motifs, aided <lb/>by both color coding and better topological arrangement. Conversely, <lb/>with FANMOD the user was able to decode 21% of the outputs. <lb/> 7.2 Evaluation Against User Requirements <lb/> The algorithm and tool were tested by two domain experts to deter-<lb/>mine how the software has met the four requirements identified in <lb/>Section 3. For each requirement, we summarize their feedback below. <lb/>1. Given a number of workflows, can we obtain the most common <lb/>patterns/motifs within those workflows? <lb/> We tested AutoMacron on nearly 10,000 workflows, the software <lb/>returned an abundance of motifs that were sorted by a score. The <lb/>filtering tools helped us in finding motifs with specific topological <lb/>events.&apos; <lb/> 2. For each motif, can we obtain the occurrence frequencies for that <lb/>motif and information about which workflows they occur in? <lb/> For each motif reported by the software, we were able to recover <lb/>statistics about how often the pattern occurred as well, how many <lb/>workflows the pattern appeared in and the names of these indi-<lb/>vidual workflows.&apos; <lb/> 3. Can we automatically create macro representations of motifs <lb/>with the added ability to add extra annotation? <lb/> C <lb/> A <lb/>B <lb/> Invalid <lb/> Invalid <lb/> Fig. 10. A) A simple experimental graph visualized using the software from Maguire et al. [24]. In this example, we are showing a specific pattern <lb/>and how that pattern is represented in both FANMOD and AutoMacron. B) HTML Output for 4-node motifs from FANMOD&apos;s analysis identifies 5 <lb/>motifs with 4 nodes. 2 are incorrect (highlighted in orange) according to our rule set in Section 4.1. C) HTML output from AutoMacron&apos;s analysis <lb/>which identifies all 50 motifs. We have highlighted the specific motif being searched for (in blue) matching the highlight pattern in A and B, and <lb/>show the other serial 4 node motifs (highlighted in grey) that would erroneously be considered the same had it not been for preserved semantics of <lb/>nodes and edges. <lb/> Each motif had three variations of &apos;macro&apos; representations cre-<lb/>ated automatically that could be used depending on the resolu-<lb/>tion available. We were able to add small pieces of text to these <lb/>to help identification of the function of these macros, e.g. label-<lb/>ing, extraction, or scanning.&apos; <lb/> 4. Can motif patterns in a workflow be substituted by common <lb/>macros to make the workflow more compact? <lb/> The software provides a function to show compressed views of <lb/>a workflow which automatically substitutes motif patterns with <lb/>their macro representation. The function was also integrated to <lb/>ISAcreator allowing us to serve out compressed representations <lb/>of workflows to our users. <lb/> Further to this, users added that the software allowed them to iden-<lb/>tify erroneous annotations very quickly. For example, through inspect-<lb/>ing the motifs, one domain expert discovered a prominent motif with <lb/>nodes in the wrong position. This was only detectable via the algo-<lb/>rithm&apos;s ability to maintain node type. On this matter, the domain expert <lb/>commented &quot; Being able to detect such errors in annotation so quickly <lb/>has enabled us to build scripts to fix those records and improve an-<lb/>notation quality. We can use this tool to find and fix inaccuracies in <lb/>biological workflows much more quickly than we could before. &quot; <lb/> In many ways, the domain experts regard AutoMacron as a time-<lb/>saving tool. Macro glyphs have a similar function to traffic signs. Do-<lb/>main experts normally expect certain macro glyphs in certain work-<lb/>flows. Although glyphs are small, they provide more assurance than <lb/>observing detailed subgraphs directly because macros are computa-<lb/>tionally determined. It has helped them to construct the motif space <lb/>computationally, which would otherwise takes years of effort. It has <lb/>enabled them to explore the space of motifs efficiently with the aid of <lb/>the ordered recommendations by the system. It has allowed them to <lb/>create macros quickly without the need to design a pictogram for each <lb/>macro. In the medium term, their everyday tasks, such as error check-<lb/>ing, comparison, and identifying best practice, can be performed more <lb/>speedily. In the long run, they also hope that this will bring benefits <lb/>to the wider community; for instance, in experimental documentation <lb/>and scientific publication. <lb/>While the discipline of biology has led the way in collecting work-<lb/>flows as part of data curation and sharing, we anticipate that some <lb/>other disciplines will follow this trend soon. Our approach to work-<lb/>flow visualization in general and macro generation in particular can be <lb/>adapted for other types of workflows if they have been curated. <lb/> 8 CONCLUSIONS AND FUTURE WORK <lb/> In this work, we introduced a new approach to macro creation aimed at <lb/>reducing visual complexity in workflow visualizations. We developed <lb/>a novel algorithm to discover motifs, with discrimination of node and <lb/>edge type in a large collection of graphs. The algorithm was specifi-<lb/>cally designed for motifs in workflows and performed more efficiently <lb/>than general-purpose motif finding algorithms. <lb/>We used a statistically-informed approach and an intuitive user in-<lb/>terface to help domain experts in selecting macros from motif can-<lb/>didates. We devised a novel design method for automated creation <lb/>of pictograms for macros by making use of the state transition infor-<lb/>mation obtained by the motif discovery algorithm. We implemented <lb/>our methods in a software system, available either through a dedi-<lb/>cate graphical user interface (GUI) or through an API. Domain experts <lb/>were able to use the system both to generate macros for compression <lb/>of workflows and to find errors in a large corpus of existing work-<lb/>flows. Additionally, the selected macros and graph substitution algo-<lb/>rithms are integrated into the ISA tools suite used by a large body of <lb/>experimental biologists [30]. <lb/>Our future work will cover two directions: the use of motif oc-<lb/>currence information to compare graphs based on &apos;motif fingerprints&apos;; <lb/>and the use of macro-based standardized constructs in an experiment <lb/>builder to simplify and improve the construction of workflows. <lb/></body>

			<div type="acknowledgement"> ACKNOWLEDGMENTS <lb/> This work was supported by funding from the BBSRC and NERC, <lb/>grants BB/I000917/1 and BB/I025840/1. <lb/></div>

			<listBibl> REFERENCES <lb/> [1] Graphviz. http://graphviz.org/, 2012. <lb/>[2] Arrayexpress. http://www.ebi.ac.uk/arrayexpress/, Last Accessed: June <lb/>2013. <lb/>[3] Neo4j. http://www.neo4j.org, Last Accessed: June 2013. <lb/>[4] Oxford <lb/>dictionaries, <lb/> Macro <lb/> definition. <lb/>http://oxforddictionaries.com/definition/english/macro, Last Accessed: <lb/>June 2013. <lb/> [5] N. Alon, P. Dao, I. Hajirasouliha, F. Hormozdiari, and S. Sahinalp. <lb/>Biomolecular network motif counting and discovery by color coding. <lb/> Bioinformatics (Oxford, England), 24(13):241–249, 2008. <lb/>[6] U. Alon. Network motifs: theory and experimental approaches. Nature <lb/>reviews. Genetics, 8(6):450–461, 2007. <lb/>[7] I. Altintas, C. Berkley, E. Jaeger, M. Jones, B. Ludascher, and S. Mock. <lb/>Kepler: an extensible system for design and execution of scientific <lb/>workflows. 16th International Conference on Scientific and Statistical <lb/>Database Management., pages 423–424, 2004. <lb/>[8] S. Batra and C. Tyagi. Comparative analysis of relational and graph <lb/>databases. Internation Journal of Soft Computing and Engineering <lb/>(IJSCE), 2, 2012. <lb/>[9] B. B. Bederson and J. D. Hollan. Pad++: a zooming graphical interface <lb/>for exploring alternate interface physics. UIST &apos;94 Proceedings of the <lb/>7th annual ACM symposium on User interface software and technology, <lb/> pages 17–26, 1994. <lb/>[10] S. P. Callahan, J. Freire, E. Santos, C. E. Scheidegger, C. T. Silva, and <lb/>H. T. Vo. VisTrails: visualization meets data management. Proceedings <lb/>of the 2006 ACM SIGMOD international conference on Management of <lb/>data, pages 745–747, 2006. <lb/>[11] J. Chen, W. Hsu, M. Lee, and S. Ng. NeMoFinder: dissecting genome-<lb/>wide protein-protein interactions with meso-scale network motifs. Pro-<lb/>ceedings of the 12th ACM SIGKDD international conference on Knowl-<lb/>edge discovery and data mining, pages 106–115, 2006. <lb/>[12] C. Dunne and B. Shneiderman. Motif simplification: improving network <lb/>visualization readability with fan, connector, and clique glyphs. CHI <lb/>&apos;13: Proc. SIGCHI Conference on Human Factors in Computing Sys-<lb/>tems, 2013. <lb/>[13] J. Grochow and M. Kellis. Network motif discovery using subgraph enu-<lb/>meration and symmetry-breaking. Proceedings of the 11th annual in-<lb/>ternational conference on Research in computational molecular biology, <lb/> pages 92–9106, 2007. <lb/>[14] J. Heer, S. K. Card, and J. A. Landay. prefuse: A toolkit for interactive <lb/>information visualization. In Proceedings of ACM CHI, pages 421–430, <lb/>2005. <lb/>[15] D. Holten. Hierarchical edge bundles: visualization of adjacency rela-<lb/>tions in hierarchical data. IEEE Transactions on Visualization and Com-<lb/>puter Graphics, 12(5):741–748, 2006. <lb/>[16] D. Hull, K. Wolstencroft, R. Stevens, C. Goble, M. Pocock, P. Li, and <lb/>T. Oinn. Taverna: a tool for building and running workflows of services. <lb/> Nucleic acids research, 34(Web Server issue):W729–W732, 2006. <lb/>[17] Z. Kashani, H. Ahrabian, E. Elahi, N. Abbas, E. Ansari, S. Asadi, S. Mo-<lb/>hammadi, F. Schreiber, and M. Ali. Kavosh: a new algorithm for finding <lb/>network motifs. BMC Bioinformatics, 10, 2009. <lb/>[18] N. Kashtan, S. Itzkovitz, R. Milo, and U. Alon. Efficient sampling al-<lb/>gorithm for estimating subgraph concentrations and detecting network <lb/>motifs. Bioinformatics, 20(11):1746–1758, 2004. <lb/>[19] N. Kashtan, S. Itzkovitz, R. Milo, and U. Alon. Network motif detection <lb/>tool mfinder tool guide. Weizmann Institute of Science: Depts of Mol Cell <lb/>Bio and Comp Sci &amp; Applied Math, Rehovot, Israel (2002-2005), 2005. <lb/>[20] D. Koop, C. Scheidegger, S. Callahan, J. Freire, and C. Silva. VisCom-<lb/>plete: automating suggestions for visualization pipelines. IEEE Transac-<lb/>tions on Visualization and Computer Graphics, 14(6):1691–1698, 2008. <lb/>[21] M. Kuramochi and G. Karypis. Finding frequent patterns in a large sparse <lb/>graph*. Data mining and knowledge discovery, 11(3):243–271, 2005. <lb/>[22] J. Leskovec and C. Faloutsos. Sampling from large graphs. Proceed-<lb/>ings of the 12th ACM SIGKDD international conference on Knowledge <lb/>discovery and data mining, pages 631–636, 2006. <lb/>[23] A. Ma&apos;ayan, S. Jenkins, R. Webb, S. Berger, S. Purushothaman, N. Abul-<lb/>Husn, J. Posner, T. Flores, and R. Iyengar. Snavi: Desktop application <lb/>for analysis and visualization of large-scale signaling networks. BMC <lb/>Systems Biology, 3, 2009. <lb/>[24] E. Maguire, P. Rocca-Serra, S.-A. Sansone, J. Davies, and M. Chen. <lb/>Taxonomy-based glyph design — with a case study on visualizing work-<lb/>flows of biological experiments. IEEE Transactions on Visualization and <lb/>Computer Graphics, 18(12), 2012. <lb/>[25] R. Milo, S. Shen-Orr, S. Itzkovitz, N. Kashtan, D. Chklovskii, and <lb/>U. Alon. Network motifs: simple building blocks of complex networks. <lb/> Science (New York, N.Y.), 298(5594):824–827, 2002. <lb/>[26] S. Omidi, F. Schreiber, and M. Ali. MODA: an efficient algorithm for net-<lb/>work motif discovery in biological networks. Genes &amp; genetic systems, <lb/> 84(5):385–395, 2009. <lb/>[27] G. Pavlopoulos, M. Secrier, C. Moschopoulos, T. Soldatos, S. Kossida, <lb/>J. Aerts, R. Schneider, and P. Bagos. Using graph theory to analyze bio-<lb/>logical networks. BioData mining, 4, 2011. <lb/>[28] P. Ribeiro and F. Silva. G-tries: an efficient data structure for discovering <lb/>network motifs. Proceedings of the 2010 ACM Symposium on Applied <lb/>Computing, pages 1559–1566, 2010. <lb/>[29] P. Rocca-Serra, E. Maguire, S.-A. Sansone, and et al. ISA software suite: <lb/>supporting standards-compliant experimental annotation and enabling cu-<lb/>ration at the community level. Bioinformatics, 26(18), 2010. <lb/>[30] S.-A. Sansone, P. Rocca-Serra, D. Field, E. Maguire, and et al. Toward <lb/>interoperable bioscience data. Nature genetics, 44(2):121–6, 2012. <lb/>[31] E. Santos, L. Lins, J. Ahrens, J. Freire, and C. Silva. VisMashup: stream-<lb/>lining the creation of custom visualization applications. IEEE Transac-<lb/>tions on Visualization and Computer Graphics, 15(6):1539–1546, 2009. <lb/>[32] C. Scheidegger, H. Vo, D. Koop, J. Freire, and C. Silva. Querying and <lb/>creating visualizations by analogy. IEEE Transactions on Visualization <lb/>and Computer Graphics, 13(6):1560–1567, 2007. <lb/>[33] F. Schreiber and H. Schwöbbermeyer. Mavisto: a tool for the exploration <lb/>of network motifs. Bioinformatics, 21(17):3572–3574, 2005. <lb/>[34] W. J. Schroeder, K. M. Martin, and W. E. Lorensen. The design and <lb/>implementation of an object-oriented toolkit for 3D graphics and visual-<lb/>ization. VIS &apos;96 Proceedings of the 7th conference on Visualization &apos;96, <lb/> pages 93–ff., 1996. <lb/>[35] B. Shneiderman. The eyes have it: A task by data type taxonomy for in-<lb/>formation visualization. Proceedings IEEE Workshop Visual Languages, <lb/> pages 336–343, 1996. <lb/>[36] B. Shneiderman and A. Aris. Network visualization by semantic sub-<lb/>strates. IEEE Transactions on Visualization and Computer Graphics, <lb/> 12(5):733–740, 2006. <lb/>[37] A. Telea and J. J. van Wijk. SMARTLINK: an agent for supporting <lb/>dataflow application construction. Springer, pages 189–198, 2000. <lb/>[38] T. von Landesberger and M. Görner. A system for interactive visual anal-<lb/>ysis of large graphs using motifs in graph editing and aggregation. Pro-<lb/>ceedings of Vision Modeling Visualization Workshop, 2009. <lb/>[39] T. von Landesberger and A. Kuijper. Visual analysis of large graphs: <lb/>State-of-the-art and future research challenges. Computer Graphics Fo-<lb/>rum, 30(6):1719–1749, 2011. <lb/>[40] C. Weaver. Building highly-coordinated visualizations in improvise. <lb/> IEEE Symposium on Information Visualization, pages 159–166, 2004. <lb/>[41] S. Wernicke and F. Rasche. Fanmod: a tool for fast network motif detec-<lb/>tion. Bioinformatics, 22(9):1152–1153, 2006. <lb/>[42] E. Wong, B. Baur, S. Quader, and C. Huang. Biological network motif de-<lb/>tection: principles and practice. Briefings in Bioinformatics, 13(2):202– <lb/>215, 2012. </listBibl>


	</text>
</tei>
